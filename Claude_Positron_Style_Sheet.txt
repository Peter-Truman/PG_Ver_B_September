# Positron8 BASIC Style Guide - IRRISYS Project
## Updated December 2025

## Critical Syntax Rules

### 1. Colon Usage - VERY IMPORTANT
**ALLOWED** (single statement after Then):
```basic
If B_I1_FlowType = Flow_Type_Dig Then B_Mode = B_Mode Or %00000001
```

**ALLOWED** (multiple variable assignments):
```basic
B_Sel = 0 : B_Top = 0
P_Sgn = B_Sgn : P_H = B_H : P_T = B_T : P_U = B_U
```

**NOT ALLOWED** (multiple statements with colons):
```basic
If X = y Then Y=X: Else Y=Y*2: EndIf
```

**Correct format for multi-statement conditionals:**
```basic
If B_Idx = B_Sel Then
    B_Act = 1
Else
    B_Act = 0
EndIf
```

### 2. Case Statement Format
**NOT ALLOWED:**
```basic
Case 0 : P_PrintRow(B_Row, "Main Menu", B_Act)
```

**CORRECT:**
```basic
Case 0
    P_PrintRow(B_Row, "Main Menu", B_Act)
```

### 3. Procedure Parameters
- **Maximum 10 parameters** per procedure
- No line continuation characters (`_`) in procedure definitions
- Use single line for procedure signature

**CORRECT:**
```basic
Proc V_InputMenu(B_In As Byte), Byte
```

### 4. Variable Assignments
**Multiple assignments on one line (with colons) - ALLOWED:**
```basic
B_Sel = 0 : B_Top = 0
```

**Multiple statements - MUST use line breaks:**
```basic
B_Len = Len S_Value
If B_Len > 8 Then
    B_Len = 8
EndIf
```

## Code Structure Guidelines

### 1. Section Organization
```basic
'---------XXXXXXXXXXXX Section N START XXXXXXXX--------
' Section content here
'---------XXXXXXXXXXXX Section N END XXXXXXXX--------
```

### 2. Procedure Structure
```basic
Proc ProcedureName(Param As Type), ReturnType
    Dim LocalVar As Type
    
    ' Procedure body
    
    Result = Value  ' For functions
EndProc
```

### 3. Control Structures
```basic
' If statements
If Condition Then
    Statement
Else
    Statement
EndIf

' Select statements  
Select Variable
    Case Value1
        Statement
    Case Value2
        Statement
    Case Else
        Statement
EndSelect

' While loops
While Condition
    Statement
Wend

' For loops
For Variable = Start To End
    Statement
Next Variable
```

## CODE DELIVERY GUIDELINES

### 1. Single Procedure Changes
When making changes to **ONE specific procedure only**:
- Deliver **only that procedure** as a standalone code block
- Include clear instructions: "**Replace the existing `P_ProcedureName` procedure in Section_X with this version**"
- Specify the exact section number where the procedure belongs

### 2. Multiple Procedure or Section Changes
When changes affect **multiple procedures or structural changes**:
- Deliver the **complete section** containing all changes
- Mark sections clearly with: `'--------------------------------XXXXXXXXX-------------------------------` and `Section_N:`
- Include clear instructions: "**Replace the entire Section_X with this updated version**"

### 3. Section Identification Requirements
- All sections MUST be clearly labeled with section numbers
- Use format: `Section_N:` where N is the section number
- Section boundaries must be clearly marked with the X-line separators

### 4. Placement Instructions
Always specify:
- **What to replace**: "Replace procedure X" or "Replace Section Y"
- **Where to place it**: "in Section_N" or "this replaces the entire Section_N" 
- **Exact procedure name**: Use backticks around procedure names like `P_EditS3Stand`

## EEPROM System Architecture

### 1. Block Structure
- System block: 32 bytes with checksum
- Input blocks: 32 bytes each with checksum
- Backup area: Mirror of main blocks
- Magic byte validation: $A5
- Version control: $01

### 2. Wear Leveling
- Write cycle tracking per block
- Automatic backup after 1000 writes
- Maximum 10000 writes per block

### 3. Error Handling
- Magic byte validation
- Checksum verification
- Backup recovery
- Legacy migration

## Menu System Architecture

### 1. Generic Input Menu
- Single parameter approach (B_In As Byte)
- Local variable copies from globals
- Save-back pattern after edits
- Adaptive field layout by sensor type

### 2. Navigation Pattern
```basic
B_NavCode = 0  ' normal
B_NavCode = 1  ' back
B_NavCode = 2  ' to main
```

### 3. UI Helpers
- Right-justified value fields
- Proper active/edit indication
- Timeout handling
- Screen dirty flags

## Advanced UI Patterns

### 1. Inline Editing with Character Blinking
```basic
Proc P_EditS3Stand(ByRef I_Val As SWord, B_Row As Byte), Byte
    ' 2Hz character blinking for active field
    ' Long press (750ms) exit with original value restoration
    ' Encoder navigation through sign->hundreds->tens->units
    ' Range validation (±500)
EndProc
```

**Key Features:**
- 2Hz blink timing (250ms intervals)
- Only active character blinks
- Long press escape (750ms) with P_Beeps(3)
- Button hold detection using ISR timing
- Proper debouncing and B_KeyEvent clearing

### 2. Button Event Management
```basic
' Clear button events after long press to prevent re-entry
B_KeyEvent = 0

' Wait for button release with debouncing
While _BTN = 0
    DelayMS 10
Wend
DelayMS 100  ' Additional debounce
```

### 3. Display Optimization
```basic
' Force update flags for efficient screen refreshes
If B_ForceUpdate = 1 Then
    B_ForceUpdate = 0
    ' Update only changed elements
EndIf
```

## Common Patterns

### 1. Editor Pattern with Long Press Exit
```basic
Proc P_EditValue(ByRef Value As Type), Byte
    Dim LocalCopy As Type
    Dim I_OrigVal As Type        ' Store for restoration
    Dim W_BtnHoldTime As Word    ' ISR timing
    
    LocalCopy = Value
    I_OrigVal = Value
    Set b_ScrDirty
    
    While 1 = 1
        ' Check for long press (750ms)
        GIE = 0
        W_BtnHoldTime = W_BtnHoldMS
        GIE = 1
        
        If W_BtnHoldTime >= 750 And _BTN = 0 Then
            P_Beeps(3)
            Value = I_OrigVal  ' Restore original
            
            ' Wait for release and debounce
            While _BTN = 0
                DelayMS 10
            Wend
            DelayMS 100
            
            B_KeyEvent = 0  ' Clear ISR event
            Result = 0      ' Exit without saving
            ExitProc
        EndIf
        
        ' Normal editing logic...
        
        If CommitCondition Then
            Value = LocalCopy
            Result = 1
            ExitProc
        EndIf
    Wend
EndProc
```

### 2. Menu Pattern with Windowing
```basic
Proc V_MenuName(), Byte
    Dim B_Sel As Byte
    Dim B_Top As Byte    ' Windowing support
    Set b_ScrDirty
    
    While 1 = 1
        ' Calculate window position
        If B_Sel <= 1 Then
            B_Top = 0
        Else
            If B_Sel >= (B_Cnt - 1) Then
                B_Top = B_Cnt - 3
            Else
                B_Top = B_Sel - 1
            EndIf
        EndIf
        
        ' Display logic with windowing
        For B_Row = 2 To 4
            B_Idx = B_Top + (B_Row - 2)
            ' Render visible items
        Next B_Row
    Wend
EndProc
```

### 3. Safe EEPROM Pattern
```basic
B_Status = P_EE_SafeWriteB(Address, Value)
If B_Status <> EE_OK Then
    Result = B_Status
    ExitProc
EndIf
```

### 4. ISR-Safe Variable Access
```basic
' Reading ISR variables
GIE = 0
W_LocalCopy = W_ISRVariable
GIE = 1

' Use W_LocalCopy for calculations
```

## Critical Functions

### 1. Core System
- `P_LoadConfig()` - Load all configuration from EEPROM
- `P_SaveInputConfig(B_InputNum)` - Save input configuration
- `P_SaveSystemConfig()` - Save system settings

### 2. UI Framework
- `P_GetKeyEvt()` - Button event processing (clears B_KeyEvent)
- `P_ReadEnc()` - Encoder input processing
- `P_Beeps(B_Type)` - Audio feedback (0-4 intensity levels)

### 3. Display Helpers
- `P_PValTxtRJ()` - Right-justified text values
- `P_PValIntRJ4()` - Right-justified signed integers
- `P_PValTmeRJ()` - Right-justified time values
- `P_ClrValFld()` - Clear 10-character value field

### 4. EEPROM Operations
- `P_EE_SafeWriteB()` - Safe byte write with verification
- `P_EE_SafeWriteW()` - Safe word write with verification
- `P_EE_ValidateBlock()` - Block integrity checking

## Timing and Performance

### 1. ISR Timing (1ms)
- Encoder debouncing: 2-sample stability
- Button hold tracking: 10ms increments
- Quadrature accumulation with threshold (±2)
- Beeper service

### 2. UI Refresh Rates
- Screen updates: On-demand with b_ScrDirty flag
- Character blinking: 2Hz (250ms intervals)
- Button long press: 750ms threshold
- Debounce delays: 100ms after button release

### 3. EEPROM Timing
- Write verification: 10ms settling + 3 retries
- Block operations: Include wear leveling checks
- Backup threshold: 1000 write cycles

## Testing Checklist

- [ ] All procedures have ≤10 parameters
- [ ] No colon-separated multi-statements in conditionals
- [ ] All Case statements use line breaks
- [ ] EEPROM operations include error checking
- [ ] Button long press exits work correctly
- [ ] Character blinking functions at 2Hz
- [ ] Menu timeouts work correctly
- [ ] Configuration saves/loads properly
- [ ] Input validation functions correctly
- [ ] ISR variables accessed safely (GIE disable/enable)

## Advanced Features Implemented

### 1. Inline Character Editor
- Real-time character blinking during edit
- Boundary checking (±500 range)
- Field-by-field navigation (sign->hundreds->tens->units)
- Long press escape with value restoration

### 2. EEPROM Wear Leveling
- Write cycle tracking per block
- Automatic backup creation
- Legacy data migration support
- Block validation with checksums

### 3. Adaptive Menu System
- Sensor-type-dependent field visibility
- Windowed display for long menus
- Generic input handling for multiple inputs
- Save-back pattern for configuration persistence

## File Recovery Notes

This style guide represents the evolved patterns from the IRRISYS project through December 2025. The code successfully compiles under Positron8 BASIC when following these guidelines. Key breakthroughs include:

- Understanding colon usage restrictions
- Parameter count limitations
- ISR timing integration for UI feedback
- Proper button event management
- Efficient display update patterns
- **Clear code delivery and placement guidelines**

**Last Updated:** December 2025  
**Architecture:** Complete EEPROM + Menu System + Advanced UI  
**Status:** Production-ready, syntax-compliant  
**Project:** IRRISYS HMI System