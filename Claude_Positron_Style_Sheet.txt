# PIC18F2525 Positron BASIC Style Sheet

## Variable Naming Conventions

### Prefixes by Type
- `B_` - Byte variables (8-bit, 0-255)
- `W_` - Word variables (16-bit, 0-65535) 
- `L_` - Long variables (32-bit)
- `S_` - Signed variables (negative values allowed)
- `I_` - Signed word variables (SWord type)

### Variable Name Length Limits
- **Byte variables**: No specific length limit observed
- **Word variables**: No specific length limit observed  
- **Dword variables**: **8 characters maximum** (e.g., `L_Blink` not `L_LastBlink`)
- **All variables**: Keep reasonably short for readability

### Examples
```basic
Dim B_Working     As Byte           ' Working value
Dim W_Scale4      As Word           ' Scale for 4mA
Dim L_Blink       As Dword          ' Blink timing (8 chars max)
Dim I_Work        As SWord          ' Signed working value
```

## Procedure Naming
- `P_` prefix for procedures
- `V_` prefix for view/menu procedures
- Descriptive names: `P_EditEnableInline`, `V_InputMenu`

## Constants and Symbols
```basic
Symbol F_ENABLE    = 0
Symbol F_SENSOR    = 1
Symbol F_FLOWTYPE  = 2
Symbol SENSOR_PRES = 0
Symbol SENSOR_TEMP = 1
Symbol SENSOR_FLOW = 2
```

## Critical Sections and ISR Protection
```basic
' Protect critical sections from interrupts
GIE = 0
W_BtnHoldTime = W_BtnHoldMS
GIE = 1
```

## Loop Exit Patterns
- **`ExitProc`** - Now available for exiting procedures (compiler updated)
- **`Break`** - Not available, use `GoTo` labels for loop exits
- **Label naming**: 8-12 characters maximum for local labels
- **Global scope**: All labels are globally scoped

### Procedure Exit Pattern (Updated)
```basic
Proc P_ExampleProc(), Byte
    While 1 = 1
        ' Loop logic
        If exit_condition Then
            Result = return_value
            ExitProc    ' Clean procedure exit
        EndIf
    Wend
EndProc
```

### Loop Exit Pattern (Still requires GoTo)
```basic
While 1 = 1
    ' Loop logic
    If exit_condition Then
        GoTo Exit_Loop    ' Use descriptive but short labels
    EndIf
Wend

Exit_Loop:
```

## Inline Editor Standards

### Structure Pattern
```basic
Proc P_Edit[Type]Inline(B_Current As Byte, B_Row As Byte), Byte
    Dim B_Working     As Byte           ' Working value
    Dim B_Modified    As Byte           ' Track changes
    Dim L_Blink       As Dword          ' 2Hz blink timing (8 chars max!)
    Dim B_BlinkState  As Byte           ' Blink visibility
    Dim B_ForceUpdate As Byte           ' Force display update
    Dim B_Original    As Byte           ' Store original value
    Dim W_BtnHoldTime As Word           ' Button hold timing
    Dim B_Col         As Byte           ' Display column
    Dim B_Start       As Byte           ' Text start position
```

### Display Formatting Rules
- **Field width**: 8 characters exactly for value field
- **Right-justification**: Pad with spaces on left
- **Tight parentheses**: Brackets immediately around text, not field edges

#### Text Alignment Examples
```basic
' 8-character field with right-justified text:
"Disabled" → "Disabled" (8 chars, no spaces)
"Enabled"  → " Enabled" (1 space + 7 chars)  
"Temp"     → "    Temp" (4 chars) 
"Analog"   → "  Analog" (2 spaces + 6 chars)
"Digital"  → " Digital" (1 space + 7 chars)
```

#### Bracket Positioning
```basic
' Brackets placed immediately around actual text:
"Disabled" → (Disabled)   ' Bracket at start of text
" Enabled" → (Enabled)    ' Bracket before 'E', not before space
"    Temp" → (Temp)       ' Bracket before 'T', not at field start
```

### Timing Standards
- **Blink rate**: 2Hz (250ms intervals)
- **Button debounce**: 100ms after release
- **System stability delay**: 1ms in main loop

### Exit Handling (Updated)
```basic
' Long press - cancel with original value
If W_BtnHoldTime >= BTN_LONG_MS And _BTN = 0 Then
    P_Beeps(3)                 ' Error beep
    Result = B_Original
    ExitProc                   ' Clean exit now available
EndIf

' Short press - commit new value  
Case 1
    P_Beeps(2)                 ' Success beep
    Result = B_Working
    ExitProc                   ' Clean exit now available
```

## Flow Sensor Architecture

### Storage Method
- **Flow type storage**: Use `B_FlowMode.0` bit (0=Analog, 1=Digital)
- **No Scale interference**: Preserves W_Scale4/W_Scale20 for analog sensors
- **EEPROM integration**: Automatically saved with existing structure

### Menu Structure
```basic
' Analog Flow: Enable, Sensor, Type, Scale4, Scale20, Display, Rly SLP, Back (8 items)
' Digital Flow: Enable, Sensor, Type, Display, Back (5 items)
```

### Variable Refresh Pattern
```basic
' When sensor type changes to Flow, refresh flow type from storage:
If B_SensorT = SENSOR_FLOW Then
    Select B_In
        Case 1: B_FlowType = B_I1_FlowMode.0
        Case 2: B_FlowType = B_I2_FlowMode.0  
        Case 3: B_FlowType = B_I3_FlowMode.0
    EndSelect
EndIf
```

## Debug Output Standards
```basic
HRSOut "DEBUG: Procedure entry - Input ", Dec B_In, 13
HRSOut "Editor returned: ", Dec B_NewValue, 13
B_KeyEvent = 0  ' Force clear at procedure entry
```

## Compiler-Specific Notes
- **Balanced structures**: All If/EndIf and Select/EndSelect must be balanced
- **Variable collisions**: Use unique local variable names (e.g., `B_InpSel` not `B_Sel`)
- **Label scope**: Labels are global - use descriptive prefixes to avoid conflicts
- **Case sensitivity**: Variables and labels are case-sensitive
- **ExitProc**: Now available for clean procedure exits (compiler updated)

## Error Patterns to Avoid
- **Long Dword names**: `L_LastBlink` → `L_Blink` (8 char limit)
- **Long labels**: `Exit_FlowType` → `Exit_FType` (12 char limit)
- **Unbalanced structures**: Missing EndIf, EndSelect statements
- **Variable collisions**: Reusing common names like `B_Sel` across procedures
- **Missing ISR protection**: Always protect shared variables with GIE disable/enable

## FLOW SENSOR CONFIGURATION
- Flow sensors support both analog (4-20mA) and digital (switch) inputs
- Configuration stored in bit-packed format:
  * FlowMode.0 = Type (0=Analog, 1=Digital)
  * FlowMode.1 = Units (0=Percent, 1=LpS) for analog only
  * DigCnf.0 = Active state (0=Low, 1=High) for digital only
- Menu structure adapts dynamically based on flow type
- Reuses SLP storage for Low Flow parameters (BP_SLP → BP_Low, RlySLP → RlyLow)