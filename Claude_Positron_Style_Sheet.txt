# Positron8 BASIC Style Guide - IRRISYS Project
## Updated December 2025

## Critical Syntax Rules

### 1. Colon Usage - VERY IMPORTANT
**ALLOWED** (single statement after Then):
```basic
If B_I1_FlowType = Flow_Type_Dig Then B_Mode = B_Mode Or %00000001
```

**ALLOWED** (multiple variable assignments):
```basic
B_Sel = 0 : B_Top = 0
P_Sgn = B_Sgn : P_H = B_H : P_T = B_T : P_U = B_U
```

**NOT ALLOWED** (multiple statements with colons):
```basic
If X = y Then Y=X: Else Y=Y*2: EndIf
```

**Correct format for multi-statement conditionals:**
```basic
If B_Idx = B_Sel Then
    B_Act = 1
Else
    B_Act = 0
EndIf
```

### 2. Case Statement Format
**NOT ALLOWED:**
```basic
Case 0 : P_PrintRow(B_Row, "Main Menu", B_Act)
```

**CORRECT:**
```basic
Case 0
    P_PrintRow(B_Row, "Main Menu", B_Act)
```

### 3. Procedure Parameters
- **Maximum 10 parameters** per procedure
- No line continuation characters (`_`) in procedure definitions
- Use single line for procedure signature
- **CRITICAL**: Never use `ByRef` with SWord parameters - causes stack corruption

**CORRECT:**
```basic
Proc V_InputMenu(B_In As Byte), Byte
Proc P_EditS3Stand(I_Val As SWord, B_Row As Byte), SWord  ' Return by value
```

**NEVER DO:**
```basic
Proc P_EditValue(ByRef I_Val As SWord)  ' CAUSES CORRUPTION
```

### 4. Variable Assignments
**Multiple assignments on one line (with colons) - ALLOWED:**
```basic
B_Sel = 0 : B_Top = 0
```

**Multiple statements - MUST use line breaks:**
```basic
B_Len = Len S_Value
If B_Len > 8 Then
    B_Len = 8
EndIf
```

## Code Structure Guidelines

### 1. Section Organization
```basic
'---------XXXXXXXXXXXX Section N START XXXXXXXX--------
' Section content here
'---------XXXXXXXXXXXX Section N END XXXXXXXX--------
```

### 2. Procedure Structure
```basic
Proc ProcedureName(Param As Type), ReturnType
    Dim LocalVar As Type
    
    ' Procedure body
    
    Result = Value  ' For functions
EndProc
```

### 3. Control Structures
```basic
' If statements
If Condition Then
    Statement
Else
    Statement
EndIf

' Select statements  
Select Variable
    Case Value1
        Statement
    Case Value2
        Statement
    Case Else
        Statement
EndSelect

' While loops
While Condition
    Statement
Wend

' For loops
For Variable = Start To End
    Statement
Next Variable
```

## CODE DELIVERY GUIDELINES

### 1. Single Procedure Changes
When making changes to **ONE specific procedure only**:
- Deliver **only that procedure** as a standalone code block
- Include clear instructions: "**Replace the existing `P_ProcedureName` procedure in Section_X with this version**"
- Specify the exact section number where the procedure belongs

### 2. Multiple Procedure or Section Changes
When changes affect **multiple procedures or structural changes**:
- Deliver the **complete section** containing all changes
- Mark sections clearly with: `'--------------------------------XXXXXXXXX-------------------------------` and `Section_N:`
- Include clear instructions: "**Replace the entire Section_X with this updated version**"

### 3. Section Identification Requirements
- All sections MUST be clearly labeled with section numbers
- Use format: `Section_N:` where N is the section number
- Section boundaries must be clearly marked with the X-line separators

### 4. Placement Instructions
Always specify:
- **What to replace**: "Replace procedure X" or "Replace Section Y"
- **Where to place it**: "in Section_N" or "this replaces the entire Section_N" 
- **Exact procedure name**: Use backticks around procedure names like `P_EditS3Stand`

### 5. Compiler Error Prevention
- **Check for duplicate procedures**: Always verify procedure names don't already exist
- **Delete wrapper procedures** if they duplicate existing ones
- **Wait for complete responses** before copying - incomplete code causes compilation errors

## EEPROM System Architecture (Simplified)

### 1. Block Structure
- System block: 32 bytes with checksum
- Input blocks: 32 bytes each with checksum
- Backup area: Mirror of main blocks (optional)
- Magic byte validation: $A5
- Version control: $01

### 2. Simplified Approach
- **Removed wear leveling** for set-and-forget applications
- Focus on reliability over write cycle optimization
- Block validation with checksums
- Backup recovery for corruption protection

### 3. Error Handling
- Magic byte validation
- Checksum verification
- Backup recovery when needed
- Legacy migration support

## Menu System Architecture

### 1. Generic Input Menu
- Single parameter approach (B_In As Byte)
- Local variable copies from globals
- Save-back pattern after edits
- Adaptive field layout by sensor type

### 2. Navigation Pattern
```basic
B_NavCode = 0  ' normal
B_NavCode = 1  ' back
B_NavCode = 2  ' to main
```

### 3. UI Helpers
- Right-justified value fields
- Proper active/edit indication
- Timeout handling
- Screen dirty flags

## Advanced Inline Editing Patterns

### 1. State-Based Inline Editing
```basic
' State variables for inline editing within menu systems
Dim B_EditMode    As Byte        ' 0=navigate, 1=editing
Dim B_EditField   As Byte        ' Which field is being edited
Dim B_EditValue   As Byte        ' Current edit value
Dim L_LastBlink   As Dword       ' Track blink timing
Dim B_BlinkState  As Byte        ' 0=show text, 1=hide text
Dim B_ForceUpdate As Byte        ' Force display update flag
```

### 2. Visual Feedback Protocol
- **Navigation mode**: `[Enabled]` with square brackets
- **Edit mode entry**: Short press → `(Enabled)` with parentheses
- **Edit mode display**: Parentheses stay fixed, only text blinks at 2Hz
- **Value changes**: Encoder movement toggles value during edit mode
- **Commit**: Second short press saves and exits to navigation mode

### 3. Precise Display Positioning (20-character LCD)
```basic
' Value field positioning for right-justified display
' "Enable    " label in columns 1-10
' Value field in columns 11-20
' "Enabled": ( at col 12, text at 13-19, ) at col 20
' "Disabled": ( at col 11, text at 12-19, ) at col 20
```

### 4. 2Hz Blink Timing Implementation
```basic
' 2Hz blinking (250ms intervals)
If (L_Millis - L_LastBlink) >= 250 Then
    L_LastBlink = L_Millis
    If B_BlinkState = 0 Then
        B_BlinkState = 1
    Else
        B_BlinkState = 0
    EndIf
    B_ForceUpdate = 1
EndIf
```

### 5. Display Update Optimization
```basic
' Separate update flags for efficiency
If b_ScrDirty = 1 Or B_ForceUpdate = 1 Then
    ' Handle full vs. partial screen updates
    If b_ScrDirty = 1 Then
        ' Full screen refresh (title, clear lines, etc.)
    EndIf
    B_ForceUpdate = 0  ' Reset partial update flag
    
    ' Render display elements
    ' ...
    
    b_ScrDirty = 0     ' Reset full refresh flag
EndIf
```

## Standalone Signed Number Editor Pattern

### 1. Parameter Passing (Critical)
```basic
' CORRECT - Pass by value, return by value
Proc P_EditS3Stand(I_Val As SWord, B_Row As Byte), SWord
    ' Work with I_Val directly
    ' Store original for restore: I_OrigVal = I_Val
    Result = I_Val  ' Return modified value
EndProc

' Usage:
I_Work = P_EditS3Stand(I_Work, B_RowSel)
```

### 2. Long Press Exit Pattern
```basic
' Check for long press (750ms) with value restoration
GIE = 0
W_BtnHoldTime = W_BtnHoldMS
GIE = 1

If W_BtnHoldTime >= 750 And _BTN = 0 Then
    P_Beeps(3)
    
    ' Wait for button release and debounce
    While _BTN = 0
        DelayMS 10
    Wend
    DelayMS 100
    
    B_KeyEvent = 0  ' Clear ISR event
    Result = I_OrigVal  ' Restore original value
    ExitProc
EndIf
```

### 3. Character Blinking with Field Navigation
```basic
' Blink only the active character/field at 2Hz
' Navigate: sign → hundreds → tens → units
' Display format: +123 or -123 (always show sign in edit mode)
```

## Button Event Management

### 1. ISR Integration
```basic
' Clear button events after long press to prevent re-entry
B_KeyEvent = 0

' Wait for button release with debouncing
While _BTN = 0
    DelayMS 10
Wend
DelayMS 100  ' Additional debounce
```

### 2. Event Processing
```basic
Proc P_GetKeyEvt(), Byte
    Result = B_KeyEvent
    B_KeyEvent = 0  ' Clear after reading
EndProc
```

## Display Helpers and Formatting

### 1. Value Field Display
```basic
Proc P_ClrValFld(B_Row As Byte, B_Col As Byte)
    Print At B_Row, B_Col, "          "  ' Clear 10 chars
EndProc

Proc P_PValTxtRJ(B_Row As Byte, B_Col As Byte, S_Value As String, B_Active As Byte, B_Edit As Byte)
    ' Right-justified text with brackets/parentheses
    ' B_Edit: 0=normal, 1=edit mode (parentheses)
EndProc
```

### 2. Signed Number Display
```basic
' Fixed format: [-001] or [001] (3 digits + optional sign)
Proc P_PValSIntRJ4(B_Row As Byte, B_Col As Byte, I_Val As SWord, B_Active As Byte, B_Edit As Byte)
    ' Display with proper bracket positioning
    ' Negative: bracket before sign [-001]
    ' Positive: bracket before first digit [001]
EndProc
```

## Common Patterns

### 1. Menu with Windowing
```basic
Proc V_MenuName(), Byte
    Dim B_Sel As Byte
    Dim B_Top As Byte    ' Windowing support
    Set b_ScrDirty
    
    While 1 = 1
        ' Calculate window position
        If B_Sel <= 1 Then
            B_Top = 0
        Else
            If B_Sel >= (B_Cnt - 1) Then
                B_Top = B_Cnt - 3
            Else
                B_Top = B_Sel - 1
            EndIf
        EndIf
        
        ' Display logic with windowing
        For B_Row = 2 To 4
            B_Idx = B_Top + (B_Row - 2)
            ' Render visible items
        Next B_Row
    Wend
EndProc
```

### 2. Safe EEPROM Pattern
```basic
B_Status = P_EE_SafeWriteB(Address, Value)
If B_Status <> EE_OK Then
    Result = B_Status
    ExitProc
EndIf
```

### 3. ISR-Safe Variable Access
```basic
' Reading ISR variables
GIE = 0
W_LocalCopy = W_ISRVariable
GIE = 1

' Use W_LocalCopy for calculations
```

## Critical Functions

### 1. Core System
- `P_LoadConfig()` - Load all configuration from EEPROM
- `P_SaveInCfg(B_InputNum)` - Save input configuration
- `P_SaveSysCfg()` - Save system settings

### 2. UI Framework
- `P_GetKeyEvt()` - Button event processing (clears B_KeyEvent)
- `P_ReadEnc()` - Encoder input processing
- `P_Beeps(B_Type)` - Audio feedback (0-4 intensity levels)

### 3. Display Helpers
- `P_PValTxtRJ()` - Right-justified text values
- `P_PValSIntRJ4()` - Right-justified signed integers
- `P_PValTmeRJ()` - Right-justified time values
- `P_ClrValFld()` - Clear 10-character value field

### 4. EEPROM Operations
- `P_EE_SafeWriteB()` - Safe byte write with verification
- `P_EE_SafeWriteW()` - Safe word write with verification
- `P_EE_ValidBlk()` - Block integrity checking

## Timing and Performance

### 1. ISR Timing (1ms)
- Encoder debouncing: 2-sample stability
- Button hold tracking: 10ms increments
- Quadrature accumulation with threshold (±2)
- Beeper service

### 2. UI Refresh Rates
- Screen updates: On-demand with b_ScrDirty flag
- Character blinking: 2Hz (250ms intervals)
- Button long press: 750ms threshold
- Debounce delays: 100ms after button release

### 3. EEPROM Timing
- Write verification: 10ms settling + 3 retries
- Block operations: Include validation checks
- Simple approach: No wear leveling for configuration data

## Testing Checklist

- [ ] All procedures have ≤10 parameters
- [ ] No colon-separated multi-statements in conditionals
- [ ] All Case statements use line breaks
- [ ] No ByRef with SWord parameters
- [ ] EEPROM operations include error checking
- [ ] Button long press exits work correctly
- [ ] Character blinking functions at 2Hz
- [ ] Menu timeouts work correctly
- [ ] Configuration saves/loads properly
- [ ] Input validation functions correctly
- [ ] ISR variables accessed safely (GIE disable/enable)
- [ ] No duplicate procedure definitions
- [ ] Inline editing visual feedback works correctly

## Critical Lessons Learned

### 1. Parameter Passing Corruption
- **Never use ByRef with SWord** - causes stack corruption and mysterious value changes
- **Always pass by value, return by value** for complex data types
- Test parameter passing thoroughly with debug output

### 2. EEPROM Complexity
- **Avoid over-engineering** wear leveling for set-and-forget applications
- **Focus on reliability** over optimization
- Simple block structure with checksums is sufficient

### 3. Display Management
- **Separate concerns**: Keep display logic separate from editing logic
- **Use update flags**: b_ScrDirty for full refresh, B_ForceUpdate for partial
- **Clear fields properly**: Use P_ClrValFld() before selective updates

### 4. Compilation Issues
- **Check for duplicates**: Always verify procedure names don't conflict
- **Wait for complete code**: Don't copy partial responses
- **Section-based delivery**: Easier to manage than small patches

## File Recovery Notes

This style guide represents the evolved patterns from the IRRISYS project through December 2025. The code successfully compiles under Positron8 BASIC when following these guidelines. Key breakthroughs include:

- Understanding colon usage restrictions
- Parameter count limitations and ByRef corruption issues
- ISR timing integration for UI feedback
- Proper button event management
- Efficient display update patterns
- **Inline editing with visual feedback**
- **Clear code delivery and placement guidelines**

**Last Updated:** December 2025  
**Architecture:** Complete EEPROM + Menu System + Advanced Inline UI  
**Status:** Production-ready, syntax-compliant  
**Project:** IRRISYS HMI System